# ğŸ”§ Corrections v3.3 - Octobre 2025

Documentation des corrections et amÃ©liorations apportÃ©es Ã  Stepzy aprÃ¨s la sÃ©paration frontend/backend.

## ğŸ“‹ Table des matiÃ¨res

- [SystÃ¨me de Seed](#systÃ¨me-de-seed)
- [Filtrage Sessions Disponibles](#filtrage-sessions-disponibles)
- [Navigation Terrain de Jeu](#navigation-terrain-de-jeu)
- [Scripts de DÃ©veloppement](#scripts-de-dÃ©veloppement)
- [Fichiers ModifiÃ©s](#fichiers-modifiÃ©s)

---

## ğŸŒ± SystÃ¨me de Seed

### ProblÃ¨me
Le script de seed crÃ©ait des "matches" (ancien systÃ¨me) au lieu d'activitÃ©s rÃ©currentes (nouveau systÃ¨me), rÃ©sultant en aucune donnÃ©e de test visible dans l'application.

### Solution
RÃ©Ã©criture complÃ¨te du script `/packages/backend/prisma/seed.ts`:

#### ActivitÃ©s crÃ©Ã©es (4)
1. **Football du mardi** 18h30-20h00 (8-12 joueurs)
2. **Badminton du mercredi** 19h00-20h00 (2-4 joueurs)
3. **Volleyball du jeudi** 17h00-19h00 (6-12 joueurs)
4. **Ping-Pong du samedi** 14h00-15h30 (2-8 joueurs)

#### Sessions gÃ©nÃ©rÃ©es
- **16 sessions** pour les 4 prochaines semaines
- GÃ©nÃ©ration basÃ©e sur `recurringDays` et `recurringType`
- Mapping des jours: `{ sunday: 0, monday: 1, tuesday: 2, ... }`

#### Abonnements et participations
```
Player1: Badminton + Football
  - Participe Ã : Badminton session 1, Football session 1

Player2: Football + Volleyball
  - Participe Ã : Football session 1, Volleyball session 1

Player3: Ping-Pong + Volleyball
  - Participe Ã : Volleyball session 1
```

#### Mot de passe admin
- Email: `admin@stepzy.local`
- Mot de passe: `RootPass123!` (alignÃ© avec README)

### Code Key
```typescript
// CrÃ©ation activitÃ©
const footballActivity = await prisma.activity.create({
  data: {
    name: 'Football du mardi',
    sport: 'football',
    recurringDays: ['tuesday'],
    recurringType: 'weekly',
    startTime: '18:30',
    endTime: '20:00',
    minPlayers: 8,
    maxPlayers: 12,
    createdBy: player1.id,
    isPublic: true,
  },
})

// GÃ©nÃ©ration sessions
for (const activity of activities) {
  for (let week = 0; week < 4; week++) {
    for (const dayName of activity.recurringDays) {
      const dayOfWeek = dayMap[dayName]
      const sessionDate = new Date(now)
      sessionDate.setDate(now.getDate() + (dayOfWeek - now.getDay() + 7) % 7 + (week * 7))

      const [hours, minutes] = activity.startTime.split(':').map(Number)
      sessionDate.setHours(hours, minutes, 0, 0)

      if (sessionDate > now) {
        await prisma.activitySession.create({
          data: {
            activityId: activity.id,
            date: sessionDate,
            maxPlayers: activity.maxPlayers,
            status: 'active',
          },
        })
      }
    }
  }
}
```

---

## ğŸ” Filtrage Sessions Disponibles

### ProblÃ¨me
L'onglet "Sessions disponibles" affichait **toutes** les sessions au lieu de filtrer par les activitÃ©s auxquelles l'utilisateur est abonnÃ©.

**Exemple**: Player1 abonnÃ© au Badminton voyait aussi Football, Volleyball et Ping-Pong.

### Cause
`getUpcomingSessions()` retournait toutes les sessions sans vÃ©rifier les abonnements (`ActivitySubscription`).

### Solution
Ajout de filtrage par abonnements dans `/packages/backend/src/services/activity-session.service.ts`:

```typescript
static async getUpcomingSessions(limit: number = 20, userId?: string) {
  // 1. RÃ©cupÃ©rer les activitÃ©s auxquelles l'utilisateur est abonnÃ©
  let subscribedActivityIds: string[] = []
  if (userId) {
    const subscriptions = await prisma.activitySubscription.findMany({
      where: { userId },
      select: { activityId: true }
    })
    subscribedActivityIds = subscriptions.map(s => s.activityId)
  }

  // 2. Filtrer les sessions par activitÃ©s abonnÃ©es
  const sessions = await prisma.activitySession.findMany({
    where: {
      date: { gte: new Date() },
      status: 'active',
      // Filtrer uniquement les activitÃ©s abonnÃ©es
      ...(userId && subscribedActivityIds.length > 0 ? {
        activityId: { in: subscribedActivityIds }
      } : {})
    },
    // ... includes ...
  })

  // 3. Exclure les sessions oÃ¹ l'utilisateur participe dÃ©jÃ 
  const enrichedSessions = sessions.map(session => {
    const userParticipant = userId
      ? session.participants.find(p => p.userId === userId)
      : null
    const isParticipant = !!userParticipant

    return {
      ...session,
      userStatus: { isParticipant, canJoin, participantStatus }
    }
  })

  return enrichedSessions.filter(s => !s.userStatus.isParticipant)
}
```

### RÃ©sultat
- âœ… Player1 voit uniquement: Badminton + Football (ses abonnements)
- âœ… Player2 voit uniquement: Football + Volleyball (ses abonnements)
- âœ… Player3 voit uniquement: Ping-Pong + Volleyball (ses abonnements)

---

## ğŸŸï¸ Navigation Terrain de Jeu

### ProblÃ¨me
Cliquer sur une session renvoyait une erreur 404 au lieu d'afficher le terrain avec les joueurs.

### Cause
1. **Route invalide**: Navigation vers `/matches/${sessionId}` qui n'existe pas
2. **API directe**: Utilisation de `fetch()` au lieu de `ApiClient` (port 3000 au lieu de 3001)
3. **Format donnÃ©es**: MatchView attend un objet `Match` avec `waitingList`

### Solution

#### 1. Navigation corrigÃ©e
`/packages/web-app/src/app/(dashboard)/mes-activites/page.tsx`:
```typescript
const handleCardClick = (e: React.MouseEvent) => {
  if ((e.target as HTMLElement).closest('button')) return
  router.push(`/sessions/${session.id}`) // âœ… ChangÃ© de /matches Ã  /sessions
}
```

#### 2. Route crÃ©Ã©e
`/packages/web-app/src/app/(dashboard)/sessions/[id]/page.tsx`:
```typescript
export default function SessionPage() {
  const sessionId = params.id as string
  const [session, setSession] = useState<SessionWithParticipants | null>(null)

  const fetchSession = async () => {
    // âœ… Utilisation de ApiClient qui pointe vers port 3001
    const result = await api.get<SessionWithParticipants>(`/api/sessions/${sessionId}`)

    if (result.success && result.data) {
      setSession(result.data)
    }
  }

  // Conversion session â†’ match
  const confirmedPlayers = session.participants
    .filter(p => p.status === 'confirmed')
    .map(p => ({ ...p, matchId: session.id }))

  const waitingPlayers = session.participants
    .filter(p => p.status === 'waiting')
    .map(p => ({ ...p, matchId: session.id }))

  const matchData: Match = {
    id: session.id,
    date: new Date(session.date),
    sport: session.activity.sport,
    maxPlayers: session.maxPlayers,
    status: session.isCancelled ? 'cancelled' : 'open',
    players: confirmedPlayers,      // âœ… Joueurs confirmÃ©s
    waitingList: waitingPlayers      // âœ… Liste d'attente
  }

  return <MatchView match={matchData} currentUser={user} />
}
```

#### 3. API Backend
L'endpoint `/api/sessions/:id` existait dÃ©jÃ  dans `/packages/backend/src/routes/sessions.routes.ts`:
```typescript
fastify.get('/api/sessions/:id', { preHandler: requireAuth }, async (request, reply) => {
  const session = await ActivitySessionService.findById(id)
  return reply.send({ success: true, data: session })
})
```

### RÃ©sultat
- âœ… Navigation fluide: `/mes-activites` â†’ `/sessions/{id}`
- âœ… Affichage terrain avec joueurs positionnÃ©s
- âœ… Liste d'attente sÃ©parÃ©e des joueurs confirmÃ©s
- âœ… Bouton "Quitter" fonctionnel

---

## ğŸš€ Scripts de DÃ©veloppement

### ProblÃ¨me
Le script `start-dev.sh` rÃ©initialisait la base de donnÃ©es Ã  chaque dÃ©marrage, perdant toutes les donnÃ©es.

### Solution
Ajout d'options pour contrÃ´ler le comportement:

```bash
#!/bin/bash

# Parse arguments
RESET_DB=false
INIT_DB=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --reset)
      RESET_DB=true
      shift
      ;;
    --init)
      INIT_DB=true
      shift
      ;;
  esac
done

# Database operations
if [ "$RESET_DB" = true ]; then
  echo "âš ï¸  Resetting database..."
  PRISMA_USER_CONSENT_FOR_DANGEROUS_AI_ACTION="yes" npx prisma migrate reset --force
else
  echo "ğŸ“Š Running database migrations..."
  npx prisma migrate deploy
fi

# Seed only if requested or after reset
if [ "$INIT_DB" = true ] || [ "$RESET_DB" = true ]; then
  echo "ğŸŒ± Seeding database..."
  npm run db:seed
fi
```

### Utilisation
```bash
# DÃ©marrer sans toucher Ã  la DB (dÃ©faut)
./start-dev.sh

# RÃ©initialiser et seed
./start-dev.sh --reset

# Ajouter donnÃ©es de test (sans reset)
./start-dev.sh --init

# Combinaison
./start-dev.sh --reset --init
```

### Mis Ã  jour dans
- `/start-dev.sh`
- `/README.md` (section Installation)
- `/packages/backend/README.md`

---

## ğŸ“ Fichiers ModifiÃ©s

### Backend
- âœ… `/packages/backend/prisma/seed.ts` - RÃ©Ã©criture complÃ¨te
- âœ… `/packages/backend/src/services/activity-session.service.ts` - Filtrage par abonnements
- âœ… `/packages/backend/API_ROUTES.md` - Documentation mise Ã  jour

### Frontend
- âœ… `/packages/web-app/src/app/(dashboard)/mes-activites/page.tsx` - Navigation corrigÃ©e
- âœ… `/packages/web-app/src/app/(dashboard)/sessions/[id]/page.tsx` - Route crÃ©Ã©e
- âœ… `/packages/web-app/src/lib/api/client.ts` - ApiClient utilisÃ©

### Scripts & Docs
- âœ… `/start-dev.sh` - Options --reset et --init
- âœ… `/README.md` - Commandes mises Ã  jour
- âœ… `/PROGRESS_SUMMARY.md` - Section v3.3 ajoutÃ©e
- âœ… `/ROADMAP.md` - Version 3.3 documentÃ©e
- âœ… `/docs/v3.3-fixes.md` - Ce document

---

## ğŸ“Š Impact

### QualitÃ© Code
- âœ… Architecture cohÃ©rente (activitÃ©s rÃ©currentes partout)
- âœ… DonnÃ©es de test rÃ©alistes et complÃ¨tes
- âœ… API Client utilisÃ© systÃ©matiquement
- âœ… SÃ©paration claire joueurs confirmÃ©s/en attente

### ExpÃ©rience Utilisateur
- âœ… Sessions disponibles pertinentes uniquement
- âœ… Navigation terrain fonctionnelle
- âœ… DonnÃ©es prÃ©servÃ©es en dÃ©veloppement
- âœ… Workflow de test simplifiÃ©

### DÃ©veloppement
- âœ… Seed rapide et fiable
- âœ… ContrÃ´le granulaire de la DB
- âœ… Documentation Ã  jour
- âœ… Types TypeScript cohÃ©rents

---

## ğŸ”— Liens Utiles

- [API Routes Documentation](/packages/backend/API_ROUTES.md)
- [Backend README](/packages/backend/README.md)
- [Progress Summary](/PROGRESS_SUMMARY.md)
- [Roadmap](/ROADMAP.md)
