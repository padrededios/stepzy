# 🔧 Corrections v3.3 - Octobre 2025

Documentation des corrections et améliorations apportées à Stepzy après la séparation frontend/backend.

## 📋 Table des matières

- [Système de Seed](#système-de-seed)
- [Filtrage Sessions Disponibles](#filtrage-sessions-disponibles)
- [Navigation Terrain de Jeu](#navigation-terrain-de-jeu)
- [Scripts de Développement](#scripts-de-développement)
- [Fichiers Modifiés](#fichiers-modifiés)

---

## 🌱 Système de Seed

### Problème
Le script de seed créait des "matches" (ancien système) au lieu d'activités récurrentes (nouveau système), résultant en aucune donnée de test visible dans l'application.

### Solution
Réécriture complète du script `/packages/backend/prisma/seed.ts`:

#### Activités créées (4)
1. **Football du mardi** 18h30-20h00 (8-12 joueurs)
2. **Badminton du mercredi** 19h00-20h00 (2-4 joueurs)
3. **Volleyball du jeudi** 17h00-19h00 (6-12 joueurs)
4. **Ping-Pong du samedi** 14h00-15h30 (2-8 joueurs)

#### Sessions générées
- **16 sessions** pour les 4 prochaines semaines
- Génération basée sur `recurringDays` et `recurringType`
- Mapping des jours: `{ sunday: 0, monday: 1, tuesday: 2, ... }`

#### Abonnements et participations
```
Player1: Badminton + Football
  - Participe à: Badminton session 1, Football session 1

Player2: Football + Volleyball
  - Participe à: Football session 1, Volleyball session 1

Player3: Ping-Pong + Volleyball
  - Participe à: Volleyball session 1
```

#### Mot de passe admin
- Email: `admin@stepzy.local`
- Mot de passe: `RootPass123!` (aligné avec README)

### Code Key
```typescript
// Création activité
const footballActivity = await prisma.activity.create({
  data: {
    name: 'Football du mardi',
    sport: 'football',
    recurringDays: ['tuesday'],
    recurringType: 'weekly',
    startTime: '18:30',
    endTime: '20:00',
    minPlayers: 8,
    maxPlayers: 12,
    createdBy: player1.id,
    isPublic: true,
  },
})

// Génération sessions
for (const activity of activities) {
  for (let week = 0; week < 4; week++) {
    for (const dayName of activity.recurringDays) {
      const dayOfWeek = dayMap[dayName]
      const sessionDate = new Date(now)
      sessionDate.setDate(now.getDate() + (dayOfWeek - now.getDay() + 7) % 7 + (week * 7))

      const [hours, minutes] = activity.startTime.split(':').map(Number)
      sessionDate.setHours(hours, minutes, 0, 0)

      if (sessionDate > now) {
        await prisma.activitySession.create({
          data: {
            activityId: activity.id,
            date: sessionDate,
            maxPlayers: activity.maxPlayers,
            status: 'active',
          },
        })
      }
    }
  }
}
```

---

## 🔍 Filtrage Sessions Disponibles

### Problème
L'onglet "Sessions disponibles" affichait **toutes** les sessions au lieu de filtrer par les activités auxquelles l'utilisateur est abonné.

**Exemple**: Player1 abonné au Badminton voyait aussi Football, Volleyball et Ping-Pong.

### Cause
`getUpcomingSessions()` retournait toutes les sessions sans vérifier les abonnements (`ActivitySubscription`).

### Solution
Ajout de filtrage par abonnements dans `/packages/backend/src/services/activity-session.service.ts`:

```typescript
static async getUpcomingSessions(limit: number = 20, userId?: string) {
  // 1. Récupérer les activités auxquelles l'utilisateur est abonné
  let subscribedActivityIds: string[] = []
  if (userId) {
    const subscriptions = await prisma.activitySubscription.findMany({
      where: { userId },
      select: { activityId: true }
    })
    subscribedActivityIds = subscriptions.map(s => s.activityId)
  }

  // 2. Filtrer les sessions par activités abonnées
  const sessions = await prisma.activitySession.findMany({
    where: {
      date: { gte: new Date() },
      status: 'active',
      // Filtrer uniquement les activités abonnées
      ...(userId && subscribedActivityIds.length > 0 ? {
        activityId: { in: subscribedActivityIds }
      } : {})
    },
    // ... includes ...
  })

  // 3. Exclure les sessions où l'utilisateur participe déjà
  const enrichedSessions = sessions.map(session => {
    const userParticipant = userId
      ? session.participants.find(p => p.userId === userId)
      : null
    const isParticipant = !!userParticipant

    return {
      ...session,
      userStatus: { isParticipant, canJoin, participantStatus }
    }
  })

  return enrichedSessions.filter(s => !s.userStatus.isParticipant)
}
```

### Résultat
- ✅ Player1 voit uniquement: Badminton + Football (ses abonnements)
- ✅ Player2 voit uniquement: Football + Volleyball (ses abonnements)
- ✅ Player3 voit uniquement: Ping-Pong + Volleyball (ses abonnements)

---

## 🏟️ Navigation Terrain de Jeu

### Problème
Cliquer sur une session renvoyait une erreur 404 au lieu d'afficher le terrain avec les joueurs.

### Cause
1. **Route invalide**: Navigation vers `/matches/${sessionId}` qui n'existe pas
2. **API directe**: Utilisation de `fetch()` au lieu de `ApiClient` (port 3000 au lieu de 3001)
3. **Format données**: MatchView attend un objet `Match` avec `waitingList`

### Solution

#### 1. Navigation corrigée
`/packages/web-app/src/app/(dashboard)/mes-activites/page.tsx`:
```typescript
const handleCardClick = (e: React.MouseEvent) => {
  if ((e.target as HTMLElement).closest('button')) return
  router.push(`/sessions/${session.id}`) // ✅ Changé de /matches à /sessions
}
```

#### 2. Route créée
`/packages/web-app/src/app/(dashboard)/sessions/[id]/page.tsx`:
```typescript
export default function SessionPage() {
  const sessionId = params.id as string
  const [session, setSession] = useState<SessionWithParticipants | null>(null)

  const fetchSession = async () => {
    // ✅ Utilisation de ApiClient qui pointe vers port 3001
    const result = await api.get<SessionWithParticipants>(`/api/sessions/${sessionId}`)

    if (result.success && result.data) {
      setSession(result.data)
    }
  }

  // Conversion session → match
  const confirmedPlayers = session.participants
    .filter(p => p.status === 'confirmed')
    .map(p => ({ ...p, matchId: session.id }))

  const waitingPlayers = session.participants
    .filter(p => p.status === 'waiting')
    .map(p => ({ ...p, matchId: session.id }))

  const matchData: Match = {
    id: session.id,
    date: new Date(session.date),
    sport: session.activity.sport,
    maxPlayers: session.maxPlayers,
    status: session.isCancelled ? 'cancelled' : 'open',
    players: confirmedPlayers,      // ✅ Joueurs confirmés
    waitingList: waitingPlayers      // ✅ Liste d'attente
  }

  return <MatchView match={matchData} currentUser={user} />
}
```

#### 3. API Backend
L'endpoint `/api/sessions/:id` existait déjà dans `/packages/backend/src/routes/sessions.routes.ts`:
```typescript
fastify.get('/api/sessions/:id', { preHandler: requireAuth }, async (request, reply) => {
  const session = await ActivitySessionService.findById(id)
  return reply.send({ success: true, data: session })
})
```

### Résultat
- ✅ Navigation fluide: `/mes-activites` → `/sessions/{id}`
- ✅ Affichage terrain avec joueurs positionnés
- ✅ Liste d'attente séparée des joueurs confirmés
- ✅ Bouton "Quitter" fonctionnel

---

## 🚀 Scripts de Développement

### Problème
Le script `start-dev.sh` réinitialisait la base de données à chaque démarrage, perdant toutes les données.

### Solution
Ajout d'options pour contrôler le comportement:

```bash
#!/bin/bash

# Parse arguments
RESET_DB=false
INIT_DB=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --reset)
      RESET_DB=true
      shift
      ;;
    --init)
      INIT_DB=true
      shift
      ;;
  esac
done

# Database operations
if [ "$RESET_DB" = true ]; then
  echo "⚠️  Resetting database..."
  PRISMA_USER_CONSENT_FOR_DANGEROUS_AI_ACTION="yes" npx prisma migrate reset --force
else
  echo "📊 Running database migrations..."
  npx prisma migrate deploy
fi

# Seed only if requested or after reset
if [ "$INIT_DB" = true ] || [ "$RESET_DB" = true ]; then
  echo "🌱 Seeding database..."
  npm run db:seed
fi
```

### Utilisation
```bash
# Démarrer sans toucher à la DB (défaut)
./start-dev.sh

# Réinitialiser et seed
./start-dev.sh --reset

# Ajouter données de test (sans reset)
./start-dev.sh --init

# Combinaison
./start-dev.sh --reset --init
```

### Mis à jour dans
- `/start-dev.sh`
- `/README.md` (section Installation)
- `/packages/backend/README.md`

---

## 📁 Fichiers Modifiés

### Backend
- ✅ `/packages/backend/prisma/seed.ts` - Réécriture complète
- ✅ `/packages/backend/src/services/activity-session.service.ts` - Filtrage par abonnements
- ✅ `/packages/backend/API_ROUTES.md` - Documentation mise à jour

### Frontend
- ✅ `/packages/web-app/src/app/(dashboard)/mes-activites/page.tsx` - Navigation corrigée
- ✅ `/packages/web-app/src/app/(dashboard)/sessions/[id]/page.tsx` - Route créée
- ✅ `/packages/web-app/src/lib/api/client.ts` - ApiClient utilisé

### Scripts & Docs
- ✅ `/start-dev.sh` - Options --reset et --init
- ✅ `/README.md` - Commandes mises à jour
- ✅ `/PROGRESS_SUMMARY.md` - Section v3.3 ajoutée
- ✅ `/ROADMAP.md` - Version 3.3 documentée
- ✅ `/docs/v3.3-fixes.md` - Ce document

---

## 📊 Impact

### Qualité Code
- ✅ Architecture cohérente (activités récurrentes partout)
- ✅ Données de test réalistes et complètes
- ✅ API Client utilisé systématiquement
- ✅ Séparation claire joueurs confirmés/en attente

### Expérience Utilisateur
- ✅ Sessions disponibles pertinentes uniquement
- ✅ Navigation terrain fonctionnelle
- ✅ Données préservées en développement
- ✅ Workflow de test simplifié

### Développement
- ✅ Seed rapide et fiable
- ✅ Contrôle granulaire de la DB
- ✅ Documentation à jour
- ✅ Types TypeScript cohérents

---

## 🔗 Liens Utiles

- [API Routes Documentation](/packages/backend/API_ROUTES.md)
- [Backend README](/packages/backend/README.md)
- [Progress Summary](/PROGRESS_SUMMARY.md)
- [Roadmap](/ROADMAP.md)
