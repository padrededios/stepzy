generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                 @id @default(cuid())
  email                  String                 @unique
  pseudo                 String
  avatar                 String?
  role                   UserRole               @default(user)
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  emailVerified          Boolean                @default(false)
  password               String?
  accounts               Account[]
  createdActivities      Activity[]             @relation("ActivityCreator")
  activityParticipations ActivityParticipant[]
  activitySubscriptions  ActivitySubscription[]
  sentAnnouncements      Announcement[]
  chatMessages           ChatMessage[]
  chatRoomReadStatus     ChatRoomReadStatus[]
  matchPlayers           MatchPlayer[]
  notifications          Notification[]         @relation("NotificationRecipient")
  sessions               Session[]
  user_activity_lists    user_activity_lists[]

  @@map("users")
}

model Match {
  id            String         @id @default(cuid())
  date          DateTime
  status        MatchStatus    @default(open)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  maxPlayers    Int            @default(12)
  sport         SportType      @default(football)
  players       MatchPlayer[]
  notifications Notification[]

  @@map("matches")
}

model MatchPlayer {
  id       String       @id @default(cuid())
  userId   String
  matchId  String
  status   PlayerStatus @default(confirmed)
  joinedAt DateTime     @default(now())
  match    Match        @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, matchId])
  @@map("match_players")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Account {
  id            String    @id @default(cuid())
  userId        String
  providerId    String
  accountId     String
  refresh_token String?
  access_token  String?
  scope         String?
  id_token      String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  password      String?
  expires_at    DateTime?
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId], map: "accounts_provider_providerAccountId_key")
  @@unique([providerId, accountId])
  @@map("accounts")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
  @@map("verifications")
}

model Notification {
  id                String           @id @default(cuid())
  userId            String
  type              NotificationType
  title             String
  message           String
  data              Json?
  read              Boolean          @default(false)
  matchId           String?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  activityId        String?
  sessionId         String?
  activities        Activity?        @relation(fields: [activityId], references: [id])
  match             Match?           @relation(fields: [matchId], references: [id])
  activity_sessions ActivitySession? @relation(fields: [sessionId], references: [id])
  user              User             @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("notifications")
}

model Announcement {
  id        String   @id @default(cuid())
  title     String
  content   String
  authorId  String
  priority  Priority @default(normal)
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@map("announcements")
}

model Activity {
  id                  String                 @id @default(cuid())
  name                String
  description         String?
  sport               SportType
  maxPlayers          Int
  createdBy           String
  isPublic            Boolean                @default(true)
  createdAt           DateTime               @default(now())
  updatedAt           DateTime               @updatedAt
  recurringDays       String[]
  recurringType       RecurringType
  minPlayers          Int                    @default(2)
  endTime             String                 @default("13:00")
  startTime           String                 @default("12:00")
  code                String                 @unique
  creator             User                   @relation("ActivityCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  sessions            ActivitySession[]
  subscriptions       ActivitySubscription[]
  chatRoom            ChatRoom?
  notifications       Notification[]
  user_activity_lists user_activity_lists[]

  @@map("activities")
}

model ActivitySession {
  id            String                @id @default(cuid())
  activityId    String
  date          DateTime
  status        SessionStatus         @default(active)
  maxPlayers    Int
  isCancelled   Boolean               @default(false)
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  participants  ActivityParticipant[]
  activity      Activity              @relation(fields: [activityId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@map("activity_sessions")
}

model ActivityParticipant {
  id        String            @id @default(cuid())
  sessionId String
  userId    String
  status    ParticipantStatus @default(interested)
  joinedAt  DateTime          @default(now())
  session   ActivitySession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@map("activity_participants")
}

model ActivitySubscription {
  id           String   @id @default(cuid())
  activityId   String
  userId       String
  subscribedAt DateTime @default(now())
  activity     Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([activityId, userId])
  @@map("activity_subscriptions")
}

model ChatRoom {
  id         String               @id @default(cuid())
  activityId String               @unique
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt
  messages   ChatMessage[]
  readStatus ChatRoomReadStatus[]
  activity   Activity             @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@map("chat_rooms")
}

model ChatMessage {
  id              String   @id @default(cuid())
  roomId          String
  senderId        String
  content         String
  originalContent String?
  isModerated     Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  room            ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  sender          User     @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([roomId, createdAt])
  @@map("chat_messages")
}

model ChatRoomReadStatus {
  id            String   @id @default(cuid())
  roomId        String
  userId        String
  lastReadAt    DateTime @default(now())
  lastMessageId String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  room          ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roomId, userId])
  @@map("chat_room_read_status")
}

model user_activity_lists {
  id         String   @id
  userId     String
  activityId String
  joinedAt   DateTime @default(now())
  activities Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  users      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, activityId])
}

enum UserRole {
  user
  root
}

enum MatchStatus {
  open
  full
  cancelled
  completed
}

enum PlayerStatus {
  confirmed
  waiting

  @@map("player_status")
}

enum SportType {
  football
  badminton
  volley
  pingpong
  rugby

  @@map("sport_type")
}

enum NotificationType {
  match_created
  match_updated
  match_cancelled
  match_reminder
  match_joined
  match_left
  waiting_list_promoted
  announcement
  system
  session_confirmed
  session_cancelled
  session_reminder
  new_sessions_available

  @@map("notification_type")
}

enum Priority {
  low
  normal
  high
  urgent

  @@map("priority")
}

enum RecurringType {
  weekly
  monthly

  @@map("recurring_type")
}

enum SessionStatus {
  active
  cancelled
  completed

  @@map("session_status")
}

enum ParticipantStatus {
  interested
  confirmed
  waiting

  @@map("participant_status")
}
